#!/usr/bin/env node --import tsx
// ─── build-songs.ts ──────────────────────────────────────────────────────────
//
// Reads songs/raw/*.mid + songs/config/*.json → generates songs/generated/*.ts
//
// Usage:
//   pnpm build:songs              # build all
//   pnpm build:songs autumn-leaves # build one song
//
// Each generated file exports a SongEntry that the registry can import.
// ─────────────────────────────────────────────────────────────────────────────

import { readdirSync, readFileSync, writeFileSync, existsSync, mkdirSync } from "node:fs";
import { join, basename, resolve } from "node:path";
import { SongConfigSchema } from "../src/config/schema.js";
import { midiToSongEntry } from "../src/midi/ingest.js";
import type { SongEntry } from "../src/types.js";

const ROOT = resolve(import.meta.dirname ?? ".", "..");
const RAW_DIR = join(ROOT, "songs", "raw");
const CONFIG_DIR = join(ROOT, "songs", "config");
const GENERATED_DIR = join(ROOT, "songs", "generated");

// ─── Main ────────────────────────────────────────────────────────────────────

function main() {
  const filter = process.argv[2]; // optional: build only one song

  // Ensure output dir exists
  if (!existsSync(GENERATED_DIR)) mkdirSync(GENERATED_DIR, { recursive: true });

  // Discover MIDI files
  if (!existsSync(RAW_DIR)) {
    console.error(`No songs/raw/ directory found at ${RAW_DIR}`);
    process.exit(1);
  }

  const midFiles = readdirSync(RAW_DIR)
    .filter(f => f.endsWith(".mid") || f.endsWith(".midi"))
    .filter(f => !filter || basename(f, ".mid") === filter || basename(f, ".midi") === filter);

  if (midFiles.length === 0) {
    console.error(filter ? `No .mid file found for "${filter}"` : "No .mid files in songs/raw/");
    process.exit(1);
  }

  let succeeded = 0;
  let failed = 0;

  for (const midFile of midFiles) {
    const songId = basename(midFile).replace(/\.midi?$/, "");
    const configPath = join(CONFIG_DIR, `${songId}.json`);
    const midiPath = join(RAW_DIR, midFile);
    const outPath = join(GENERATED_DIR, `${songId}.ts`);

    // Check config exists
    if (!existsSync(configPath)) {
      console.error(`SKIP ${songId}: no config file at ${configPath}`);
      failed++;
      continue;
    }

    try {
      // Read + validate config
      const rawConfig = JSON.parse(readFileSync(configPath, "utf8"));
      const config = SongConfigSchema.parse(rawConfig);

      // Read MIDI
      const midiBuffer = new Uint8Array(readFileSync(midiPath));

      // Convert
      const entry = midiToSongEntry(midiBuffer, config);

      // Write generated TypeScript
      const tsContent = generateTsFile(entry);
      writeFileSync(outPath, tsContent, "utf8");

      console.log(`OK ${songId}: ${entry.measures.length} measures → ${outPath}`);
      succeeded++;
    } catch (err) {
      const msg = err instanceof Error ? err.message : String(err);
      console.error(`FAIL ${songId}: ${msg}`);
      failed++;
    }
  }

  console.log(`\nDone. ${succeeded} succeeded, ${failed} failed.`);
  if (failed > 0) process.exit(1);
}

// ─── Code Generation ─────────────────────────────────────────────────────────

function generateTsFile(entry: SongEntry): string {
  const json = JSON.stringify(entry, null, 2);

  return `// Auto-generated by build-songs.ts — DO NOT EDIT
import type { SongEntry } from "../../src/types.js";

const song: SongEntry = ${json};

export default song;
`;
}

// ─── Run ─────────────────────────────────────────────────────────────────────

main();
